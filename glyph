#!/usr/bin/env python3

import argparse
import json
import sys
import logging
from pathlib import Path
from core.container import create_container
from core.models import Scenario


# Configure logging
logging.basicConfig(level=logging.INFO, format='%(message)s')
logger = logging.getLogger(__name__)

def build_command(scenarios_path: str = None, scenario_file: str = None, debug_stop: int = None, purge: bool = False, verbose: bool = False, quiet: bool = False):
    """Build Playwright tests from scenarios."""
    try:
        # Create DI container
        container = create_container()
        config = container.get('config')
        target = container.get('target')
        scenario_builder = container.get('scenario_builder')
        filesystem = container.get('filesystem')
        
        # Configure output verbosity
        from core.build_output_manager import build_output, OutputLevel
        if quiet:
            build_output.set_level(OutputLevel.QUIET)
        elif verbose:
            build_output.set_level(OutputLevel.VERBOSE)
        else:
            build_output.set_level(OutputLevel.NORMAL)
        
        logger.info(f"Initialized target: {target.name}")
        
        logger.info("Setting up test environment...")
        target.init()
        
        # Determine scenarios directory and specific scenario
        scenarios_dir = scenarios_path or 'scenarios'
        
        # Check if scenarios_path is a file (specific scenario)
        if scenarios_path and scenarios_path.endswith('.glyph'):
            # scenarios_path is a specific scenario file
            scenario_file = scenarios_path
            # Find the directory containing this file
            scenarios_dir = str(Path(scenarios_path).parent)
            if scenarios_dir == '.':
                scenarios_dir = 'scenarios'  # Default if in current directory
        
        # Validate scenarios directory
        if not filesystem.exists(scenarios_dir):
            logger.error(f"Error: Scenarios directory '{scenarios_dir}' not found")
            sys.exit(1)
        if not filesystem.is_dir(scenarios_dir):
            logger.error(f"Error: '{scenarios_dir}' is not a directory")
            sys.exit(1)
        
        glyph_files = filesystem.glob(f"{scenarios_dir}/*.glyph")
        if not glyph_files:
            logger.warning(f"No .glyph files found in '{scenarios_dir}'")
            return
        
        all_scenarios = []
        for glyph_file in glyph_files:
            try:
                scenario = Scenario.from_file(glyph_file, filesystem)
                all_scenarios.append(scenario)
            except Exception as e:
                logger.error(f"‚ùå Failed to load {filesystem.get_name(glyph_file)}: {e}")
        
        if not all_scenarios:
            logger.error("No scenarios could be loaded")
            sys.exit(1)
        
        # Filter scenarios based on scenario_file parameter
        scenarios_to_build = []
        if scenario_file:
            target_scenario = None
            for scenario in all_scenarios:
                if scenario.name == filesystem.get_stem(scenario_file):
                    target_scenario = scenario
                    break
            
            if target_scenario:
                scenarios_to_build = [target_scenario]
                logger.info(f"Building single scenario: {target_scenario.name}")
            else:
                logger.error(f"Error: Scenario '{scenario_file}' not found in available scenarios")
                logger.info(f"Available scenarios: {[s.name for s in all_scenarios]}")
                sys.exit(1)
        else:
            scenarios_to_build = all_scenarios
            logger.info(f"Building {len(scenarios_to_build)} scenarios from {scenarios_dir}")
        
        # Handle purge if requested
        if purge:
            logger.info("üßπ Purge requested - removing all cached knowledge")
            caching_system = container.get('hash_caching')
            caching_system.purge_cached_knowledge()
            logger.info("‚úÖ Purge completed - agent will analyze scenarios fresh")
        
        # Build scenarios layer by layer using dependency graph with iterative knowledge building
        successful_builds = 0
        
        # Build scenario graph directly from scenarios using agent analysis
        from core.scenario_graph_agent import ScenarioGraphAgent
        from core.test_generation_agent import TestGenerationAgent
        
        scenario_builder = container.get('scenario_builder')
        agent = TestGenerationAgent(scenario_builder)
        graph_agent = ScenarioGraphAgent(agent)
        
        graph = graph_agent.build_graph_from_scenarios(scenarios_path or 'scenarios')
        
        # Get build layers (leaves to root)
        build_layers = graph.get_build_layers()
        logger.info(f"üìä Build layers identified: {len(build_layers)} layers")
        
        # For single scenario builds, identify the dependency subtree
        if len(scenarios_to_build) == 1:
            target_scenario = scenarios_to_build[0].name
            build_layers = graph_agent.filter_build_layers_for_target(graph, target_scenario)
        
        # Build scenarios layer by layer with iterative knowledge building
        for layer_index, layer in enumerate(build_layers, 1):
            logger.info(f"\nüèóÔ∏è  Building Layer {layer_index}/{len(build_layers)} ({len(layer)} scenarios)")
            logger.info(f"   Scenarios in this layer: {', '.join(layer)}")
            
            # When building a single scenario, build all its dependencies recursively
            # When building all scenarios, only build scenarios in our target list
            if len(scenarios_to_build) == 1:
                # Single scenario build - only build the target scenario in this layer
                layer_scenarios = [s for s in layer if s == scenarios_to_build[0].name]
                if not layer_scenarios:
                    logger.info(f"   ‚è≠Ô∏è  Target scenario not in this layer, skipping...")
                    continue
                logger.info(f"   üéØ Building target scenario: {', '.join(layer_scenarios)}")
            else:
                # Full build - only build scenarios in our target list
                layer_scenarios = [s for s in layer if s in [sc.name for sc in scenarios_to_build]]
                if not layer_scenarios:
                    logger.info(f"   ‚è≠Ô∏è  No target scenarios in this layer, skipping...")
                    continue
                logger.info(f"   üéØ Building {len(layer_scenarios)} target scenarios: {', '.join(layer_scenarios)}")
            
            # Build all scenarios in this layer
            for scenario_name in layer_scenarios:
                try:
                    # Find the scenario object (might be in all_scenarios, not just scenarios_to_build)
                    scenario = next((s for s in all_scenarios if s.name == scenario_name), None)
                    if not scenario:
                        logger.error(f"‚ùå Scenario '{scenario_name}' not found in available scenarios")
                        continue
                    
                    # For single scenario builds, recursively build dependencies first
                    if len(scenarios_to_build) == 1:
                        dependencies = graph.get_dependencies_for_scenario(scenario_name)
                        for dep in dependencies:
                            if not graph.nodes[dep].built:
                                logger.info(f"üîó Building dependency: {dep}")
                                dep_scenario = next((s for s in all_scenarios if s.name == dep), None)
                                if dep_scenario:
                                    scenario_builder.build_scenario(dep_scenario, debug_stop=debug_stop)
                                    graph.mark_scenario_built(dep)
                                    logger.info(f"‚úÖ Built dependency: {dep}")
                                else:
                                    logger.error(f"‚ùå Dependency '{dep}' not found in available scenarios")
                    
                    logger.info(f"\n--- Building {scenario.name} (Layer {layer_index}) ---")
                    scenario_builder.build_scenario(scenario, debug_stop=debug_stop)
                    logger.info(f"‚úÖ Successfully built: {scenario.name}")
                    successful_builds += 1
                    
                    # Mark as built in the graph
                    graph.mark_scenario_built(scenario_name)
                    
                except Exception as e:
                    logger.error(f"‚ùå Failed to build {scenario_name}: {e}")
                    # Continue with other scenarios in the layer
            
        
        # Summary
        total_scenarios = len(scenarios_to_build)
        if successful_builds == total_scenarios:
            logger.info(f"\nüéâ Successfully built all {total_scenarios} scenarios in {len(build_layers)} layers!")
        else:
            logger.warning(f"\n‚ö†Ô∏è  Built {successful_builds}/{total_scenarios} scenarios")
            if successful_builds < total_scenarios:
                sys.exit(1)
        
        # Show build summary
        from core.build_output_manager import build_output
        build_output.build_summary(total_scenarios, successful_builds)
    except Exception as e:
        logger.error(f"‚ùå Build failed: {e}")
        sys.exit(1)


def init_command():
    """Initialize the GlyphQA project structure."""
    try:
        # Create DI container
        container = create_container()
        config = container.get('config')
        target = container.get('target')
        logger.info(f"Initialized target: {target.name}")
        
        logger.info("Setting up test environment...")
        target.init()
        logger.info("‚úÖ Project initialized successfully!")
        
    except Exception as e:
        logger.error(f"‚ùå Initialization failed: {e}")
        sys.exit(1)


def purge_command():
    """Purge all cached knowledge and start fresh."""
    try:
        # Create DI container
        container = create_container()
        caching_system = container.get('hash_caching')
        
        logger.info("üßπ Purging cached knowledge...")
        
        # Purge cached knowledge
        caching_system.purge_cached_knowledge()
        
        logger.info("‚úÖ Cache purged successfully!")
        
    except Exception as e:
        logger.error(f"‚ùå Purge failed: {e}")
        sys.exit(1)


def visualize_command(scenario_name: str = None, tree: bool = False):
    """Visualize the scenario dependency graph."""
    try:
        from core.scenario_graph_agent import ScenarioGraphAgent
        from core.test_generation_agent import TestGenerationAgent
        
        # Create agent instance
        container = create_container()
        scenario_builder = container.get('scenario_builder')
        agent = TestGenerationAgent(scenario_builder)
        graph_agent = ScenarioGraphAgent(agent)
        
        graph = graph_agent.build_graph_from_scenarios('scenarios')
        
        if tree and scenario_name:
            print(graph.visualize_dependency_tree(scenario_name))
        elif scenario_name:
            print(graph.visualize_graph(scenario_name))
        else:
            print(graph.visualize_graph())
            
    except Exception as e:
        logger.error(f"‚ùå Visualization failed: {e}")
        sys.exit(1)


def test_command(scenario_file: str = None):
    """Run Playwright tests with optional scenario filter."""
    try:
        import subprocess
        import os
        
        # Check if .glyph directory exists
        if not os.path.exists('.glyph'):
            logger.error("‚ùå No .glyph directory found. Run 'glyph build' first to generate tests.")
            sys.exit(1)
        
        # Check if tests directory exists
        if not os.path.exists('.glyph/tests'):
            logger.error("‚ùå No tests directory found. Run 'glyph build' first to generate tests.")
            sys.exit(1)
        
        # Build the test command
        test_cmd = ['npm', 'test']
        
        # Add scenario filter if specified
        if scenario_file:
            # Remove .glyph extension if present
            scenario_name = scenario_file.replace('.glyph', '')
            test_file = f"{scenario_name}.spec.js"
            test_cmd.append(test_file)
            logger.info(f"üß™ Running tests for scenario: {scenario_name}")
        else:
            logger.info("üß™ Running all tests")
        
        # Change to .glyph directory and run tests
        original_dir = os.getcwd()
        os.chdir('.glyph')
        
        try:
            # Run the test command and proxy stdout/stderr
            result = subprocess.run(test_cmd, capture_output=False)
            return result.returncode
        finally:
            # Always return to original directory
            os.chdir(original_dir)
            
    except FileNotFoundError:
        logger.error("‚ùå npm not found. Make sure Node.js and npm are installed.")
        sys.exit(1)
    except Exception as e:
        logger.error(f"‚ùå Test execution failed: {e}")
        sys.exit(1)


def main():
    parser = argparse.ArgumentParser(description='GlyphQA - LLM-powered test automation framework')
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Init command
    init_parser = subparsers.add_parser('init', help='Initialize the project structure')
    
    
    # Build command
    build_parser = subparsers.add_parser('build', help='Build Playwright tests from scenarios using step mapping approach')
    build_parser.add_argument('scenarios_path', nargs='?', default='scenarios', help='Path to scenarios directory or specific scenario file (default: scenarios/)')
    build_parser.add_argument('--scenario', help='Build specific scenario file (deprecated, use scenarios_path instead)')
    build_parser.add_argument('--debug-stop', type=int, help='Stop at specific action number for debugging')
    build_parser.add_argument('--purge', action='store_true', help='Remove all cached knowledge and start fresh')
    build_parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output with detailed debugging information')
    build_parser.add_argument('--quiet', '-q', action='store_true', help='Quiet output - only show errors and final results')
    
    # Purge command
    purge_parser = subparsers.add_parser('purge', help='Purge all cached knowledge and start fresh')
    
    # Visualize command
    visualize_parser = subparsers.add_parser('visualize', help='Visualize scenario dependency graph')
    visualize_parser.add_argument('--scenario', help='Focus on specific scenario')
    visualize_parser.add_argument('--tree', action='store_true', help='Show dependency tree instead of graph')
    
    # Test command
    test_parser = subparsers.add_parser('test', help='Run Playwright tests')
    test_parser.add_argument('--scenario', help='Run tests for specific scenario file')
    
    args = parser.parse_args()
    
    if args.command == 'init':
        init_command()
    elif args.command == 'build':
        # Handle both new scenarios_path and deprecated --scenario argument
        scenarios_path = args.scenarios_path
        scenario_file = args.scenario
        
        # If scenarios_path is a file, treat it as a specific scenario
        if scenarios_path and scenarios_path.endswith('.glyph'):
            scenario_file = scenarios_path
            scenarios_path = None  # Will use default scenarios directory
        
        build_command(scenarios_path, scenario_file, args.debug_stop, args.purge, args.verbose, args.quiet)
    elif args.command == 'purge':
        purge_command()
    elif args.command == 'visualize':
        visualize_command(args.scenario, args.tree)
    elif args.command == 'test':
        test_command(args.scenario)
    else:
        parser.print_help()


if __name__ == '__main__':
    main()
