#!/usr/bin/env python3

import argparse
import json
import sys
import logging
from pathlib import Path
from core.container import create_container
from core.models import Scenario

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(message)s')
logger = logging.getLogger(__name__)


def analyze_guide_patterns(guides_dir: str, filesystem, llm_provider, template_manager) -> dict:
    """Analyze guide files to identify common patterns for SDK design using LLM."""
    try:
        guide_files = filesystem.glob(f"{guides_dir}/*.guide")
        all_guides_data = []
        
        # Load all guide data
        for guide_file in guide_files:
            try:
                with open(guide_file, 'r') as f:
                    guide_data = json.load(f)
                    all_guides_data.append(guide_data)
            except Exception as e:
                logger.warning(f"Failed to load guide {guide_file}: {e}")
        
        if not all_guides_data:
            logger.warning("No guide data to analyze")
            return {}
        
        # Let the LLM analyze the patterns using template
        logger.info("Using LLM to analyze patterns with template...")
        
        # Use template for pattern analysis
        template_path = 'pattern_analysis.j2'
        prompt = template_manager.render_template(template_path, guide_data=json.dumps(all_guides_data, indent=2))
        logger.info("Successfully rendered pattern analysis template")
        
        # Get LLM analysis
        response = llm_provider.generate(prompt, "pattern_analysis")
        
        # Return the LLM's analysis as a simple dict
        return {
            'llm_analysis': response,
            'guide_count': len(all_guides_data),
            'raw_guides': all_guides_data
        }
        
    except Exception as e:
        logger.warning(f"Failed to analyze guides: {e}")
        return {}


def load_command(scenarios_path: str = None, skip_setup: bool = False):
    """Load scenarios and convert them to .guide files with action lists."""
    try:
        # Create DI container
        container = create_container()
        config = container.get('config')
        filesystem = container.get('filesystem')
        llm_provider = container.get('llm_provider')
        template_manager = container.get('template_manager')
        
        logger.info(f"Successfully loaded config from glyph.config.yml")
        
        # Create .glyph/guides directory (skip if called from build process)
        if not skip_setup:
            guides_dir = '.glyph/guides'
            filesystem.mkdir(guides_dir, parents=True, exist_ok=True)
            logger.info(f"Created guides directory: {guides_dir}")
        else:
            guides_dir = '.glyph/guides'
        
        # Load all scenarios from the specified directory
        scenarios_dir = scenarios_path or 'scenarios'
        if not filesystem.exists(scenarios_dir):
            logger.error(f"Error: Scenarios directory '{scenarios_dir}' not found")
            sys.exit(1)
        if not filesystem.is_dir(scenarios_dir):
            logger.error(f"Error: '{scenarios_dir}' is not a directory")
            sys.exit(1)
        
        glyph_files = filesystem.glob(f"{scenarios_dir}/*.glyph")
        if not glyph_files:
            logger.warning(f"No .glyph files found in '{scenarios_dir}'")
            return
        
        logger.info(f"Found {len(glyph_files)} .glyph files")
        
        # Step 1: Load all scenarios
        all_scenarios = []
        for glyph_file in glyph_files:
            try:
                scenario = Scenario.from_file(glyph_file, filesystem)
                all_scenarios.append(scenario)
                logger.info(f"Loaded scenario: {scenario.name}")
            except Exception as e:
                logger.error(f"‚ùå Failed to load {filesystem.get_name(glyph_file)}: {e}")
        
        if not all_scenarios:
            logger.error("No scenarios could be loaded")
            sys.exit(1)
        
        # Step 2: Generate summaries for all scenarios with caching
        logger.info("\n--- Generating scenario summaries ---")
        scenario_summaries = {}
        
        # Get caching system for hash-based summary rebuild prevention
        caching_system = container.get('hash_caching')
        from core.hash_caching import calculate_glyph_hash
        import json
        
        for scenario in all_scenarios:
            try:
                logger.info(f"Summarizing {scenario.name}...")
                
                # Check if we have a cached summary
                glyph_file_path = f"{scenarios_dir}/{scenario.name}.glyph"
                cached_guide = caching_system.load_guide(scenario.name)
                
                if cached_guide and cached_guide.glyph_hash == calculate_glyph_hash(glyph_file_path, filesystem):
                    # Use cached summary from the guide file
                    guide_file = f"{guides_dir}/{scenario.name}.guide"
                    if filesystem.exists(guide_file):
                        try:
                            guide_content = filesystem.read_text(guide_file)
                            guide_data = json.loads(guide_content)
                            summary = guide_data.get('summary', f"Scenario: {scenario.name}")
                            scenario_summaries[scenario.name] = summary
                            logger.info(f"‚úÖ Using cached summary for {scenario.name}")
                            continue
                        except Exception as e:
                            logger.warning(f"Failed to load cached summary for {scenario.name}: {e}")
                
                # Generate new summary using LLM
                summary = scenario.summarize(llm_provider, template_manager)
                scenario_summaries[scenario.name] = summary
                logger.info(f"  Summary: {summary}")
                
            except Exception as e:
                logger.error(f"‚ùå Failed to summarize {scenario.name}: {e}")
                # Use a fallback summary
                scenario_summaries[scenario.name] = f"Scenario: {scenario.name}"
        
        # Step 3: Generate action lists using the summary dictionary with caching
        logger.info("\n--- Generating action lists ---")
        successful_loads = 0
        
        # Get caching system for hash-based guide rebuild prevention
        caching_system = container.get('hash_caching')
        
        for scenario in all_scenarios:
            try:
                logger.info(f"\n--- Loading {scenario.name} ---")
                
                # Check if guide needs rebuilding based on hash
                glyph_file_path = f"{scenarios_dir}/{scenario.name}.glyph"
                if caching_system.should_rebuild_guide(scenario.name, glyph_file_path, force=False):
                    # Generate action list using LLM with scenario summaries context
                    logger.info("Generating action list...")
                    actions = scenario.list_actions(llm_provider, template_manager, scenario_summaries)
                    logger.info(f"Generated {len(actions)} actions")
                    
                    # Create guide object and save as JSON
                    from core.models import Guide
                    guide = Guide(
                        name=scenario.name,
                        original_scenario=f"{scenario.name}.glyph",
                        actions=actions
                    )
                    
                    guide_file = f"{guides_dir}/{scenario.name}.guide"
                    guide.save(guide_file, filesystem)
                    
                    # Add summary and hash information to the guide file for caching
                    try:
                        from datetime import datetime
                        guide_content = filesystem.read_text(guide_file)
                        guide_data = json.loads(guide_content)
                        guide_data['summary'] = scenario_summaries.get(scenario.name, f"Scenario: {scenario.name}")
                        guide_data['glyph_hash'] = calculate_glyph_hash(glyph_file_path, filesystem)
                        guide_data['built_at'] = datetime.now().isoformat()
                        filesystem.write_text(guide_file, json.dumps(guide_data, indent=2))
                    except Exception as e:
                        logger.warning(f"Failed to save summary and hash to guide file for {scenario.name}: {e}")
                    
                    logger.info(f"‚úÖ Saved guide: {guide_file}")
                    successful_loads += 1
                else:
                    logger.info(f"‚úÖ Guide up to date for {scenario.name}")
                    successful_loads += 1
                
            except Exception as e:
                logger.error(f"‚ùå Failed to load {scenario.name}: {e}")
        
        # Step 4: Analyze patterns and update glyph.md
        logger.info("\n--- Analyzing patterns and updating glyph.md ---")
        try:
            from core.scenario_builder import SystemStateManager
            from core.system_state_storage_manager import SystemStateStorageManager
            
            # Create system state manager
            system_state = SystemStateStorageManager('.glyph')
            system_state_manager = SystemStateManager(system_state, llm_provider, template_manager)
            
            # Analyze patterns from generated guides
            logger.info("Analyzing patterns from guides...")
            pattern_analysis = analyze_guide_patterns(guides_dir, filesystem, llm_provider, template_manager)
            
            # Update glyph.md with pattern analysis
            logger.info("Updating glyph.md with pattern analysis...")
            system_state_manager.update_glyph_md_with_patterns(pattern_analysis)
            
            logger.info("‚úÖ Successfully updated glyph.md with pattern analysis")
            
        except Exception as e:
            logger.error(f"‚ùå Failed to update glyph.md: {e}")
            logger.warning("Continuing without pattern analysis...")
        
        # Summary
        total_scenarios = len(all_scenarios)
        if successful_loads == total_scenarios:
            logger.info(f"\nüéâ Successfully loaded all {total_scenarios} scenarios!")
        else:
            logger.warning(f"\n‚ö†Ô∏è  Loaded {successful_loads}/{total_scenarios} scenarios")
            if successful_loads < total_scenarios:
                sys.exit(1)
                
    except Exception as e:
        logger.error(f"‚ùå Load failed: {e}")
        sys.exit(1)


def build_command(scenarios_path: str = None, scenario_file: str = None, debug_stop: int = None, purge: bool = False):
    """Build Playwright tests from scenarios."""
    try:
        # Create DI container
        container = create_container()
        config = container.get('config')
        target = container.get('target')
        scenario_builder = container.get('scenario_builder')
        filesystem = container.get('filesystem')
        
        logger.info(f"Initialized target: {target.name}")
        
        logger.info("Setting up test environment...")
        target.init()
        
        # Load all available scenarios
        scenarios_dir = scenarios_path or 'scenarios'
        if not filesystem.exists(scenarios_dir):
            logger.error(f"Error: Scenarios directory '{scenarios_dir}' not found")
            sys.exit(1)
        if not filesystem.is_dir(scenarios_dir):
            logger.error(f"Error: '{scenarios_dir}' is not a directory")
            sys.exit(1)
        
        glyph_files = filesystem.glob(f"{scenarios_dir}/*.glyph")
        if not glyph_files:
            logger.warning(f"No .glyph files found in '{scenarios_dir}'")
            return
        
        all_scenarios = []
        for glyph_file in glyph_files:
            try:
                scenario = Scenario.from_file(glyph_file, filesystem)
                all_scenarios.append(scenario)
            except Exception as e:
                logger.error(f"‚ùå Failed to load {filesystem.get_name(glyph_file)}: {e}")
        
        if not all_scenarios:
            logger.error("No scenarios could be loaded")
            sys.exit(1)
        
        # Filter scenarios based on scenario_file parameter
        scenarios_to_build = []
        if scenario_file:
            target_scenario = None
            for scenario in all_scenarios:
                if scenario.name == filesystem.get_stem(scenario_file):
                    target_scenario = scenario
                    break
            
            if target_scenario:
                scenarios_to_build = [target_scenario]
                logger.info(f"Building single scenario: {target_scenario.name}")
            else:
                logger.error(f"Error: Scenario '{scenario_file}' not found in available scenarios")
                logger.info(f"Available scenarios: {[s.name for s in all_scenarios]}")
                sys.exit(1)
        else:
            scenarios_to_build = all_scenarios
            logger.info(f"Building {len(scenarios_to_build)} scenarios from {scenarios_dir}")
        
        # Handle purge if requested
        if purge:
            logger.info("üßπ Purge requested - removing all cached knowledge")
            caching_system = container.get('hash_caching')
            system_state_storage_manager = container.get('system_state_storage_manager')
            caching_system.purge_cached_knowledge(system_state_storage_manager)
            logger.info("‚úÖ Purge completed - reloading guides for fresh build")
            
            # Reload guides after purge
            logger.info("üîÑ Reloading guides after purge...")
            load_command(scenarios_path, skip_setup=True)
        
        # Build scenarios layer by layer using dependency graph with iterative knowledge building
        successful_builds = 0
        
        # First, ensure we have guides loaded for dependency analysis
        guides_dir = Path('.glyph/guides')
        if not guides_dir.exists():
            logger.error("No guides found. Run 'glyph load' first to create guides for dependency analysis.")
            sys.exit(1)
        
        # Build scenario graph
        graph_builder = container.get('scenario_graph_builder')
        graph = graph_builder.build_graph_from_guides()
        
        # Get build layers (leaves to root)
        build_layers = graph.get_build_layers()
        logger.info(f"üìä Build layers identified: {len(build_layers)} layers")
        
        # For single scenario builds, identify the dependency subtree
        if len(scenarios_to_build) == 1:
            target_scenario = scenarios_to_build[0].name
            # Get all dependencies recursively (what the target needs)
            dependencies = set()
            to_process = [target_scenario]
            while to_process:
                current = to_process.pop(0)
                deps = graph.get_dependencies_for_scenario(current)
                for dep in deps:
                    if dep not in dependencies:
                        dependencies.add(dep)
                        to_process.append(dep)
            
            # Only build layers that contain dependencies or the target
            dependency_subtree = dependencies | {target_scenario}
            logger.info(f"üéØ Building dependency subtree for {target_scenario}: {', '.join(sorted(dependency_subtree))}")
            
            # Filter build layers to only include dependency subtree
            filtered_build_layers = []
            for layer in build_layers:
                layer_deps = [s for s in layer if s in dependency_subtree]
                if layer_deps:
                    filtered_build_layers.append(layer_deps)
                else:
                    logger.info(f"‚è≠Ô∏è  Skipping layer {', '.join(layer)} (not in dependency subtree)")
            
            build_layers = filtered_build_layers
            logger.info(f"üìä Filtered to {len(build_layers)} dependency layers")
        
        # Build scenarios layer by layer with iterative knowledge building
        for layer_index, layer in enumerate(build_layers, 1):
            logger.info(f"\nüèóÔ∏è  Building Layer {layer_index}/{len(build_layers)} ({len(layer)} scenarios)")
            logger.info(f"   Scenarios in this layer: {', '.join(layer)}")
            
            # When building a single scenario, build all its dependencies recursively
            # When building all scenarios, only build scenarios in our target list
            if len(scenarios_to_build) == 1:
                # Single scenario build - only build the target scenario in this layer
                layer_scenarios = [s for s in layer if s == scenarios_to_build[0].name]
                if not layer_scenarios:
                    logger.info(f"   ‚è≠Ô∏è  Target scenario not in this layer, skipping...")
                    continue
                logger.info(f"   üéØ Building target scenario: {', '.join(layer_scenarios)}")
            else:
                # Full build - only build scenarios in our target list
                layer_scenarios = [s for s in layer if s in [sc.name for sc in scenarios_to_build]]
                if not layer_scenarios:
                    logger.info(f"   ‚è≠Ô∏è  No target scenarios in this layer, skipping...")
                    continue
                logger.info(f"   üéØ Building {len(layer_scenarios)} target scenarios: {', '.join(layer_scenarios)}")
            
            # Build all scenarios in this layer
            for scenario_name in layer_scenarios:
                try:
                    # Find the scenario object (might be in all_scenarios, not just scenarios_to_build)
                    scenario = next((s for s in all_scenarios if s.name == scenario_name), None)
                    if not scenario:
                        logger.error(f"‚ùå Scenario '{scenario_name}' not found in available scenarios")
                        continue
                    
                    # For single scenario builds, recursively build dependencies first
                    if len(scenarios_to_build) == 1:
                        dependencies = graph.get_dependencies_for_scenario(scenario_name)
                        for dep in dependencies:
                            if not graph.nodes[dep].built:
                                logger.info(f"üîó Building dependency: {dep}")
                                dep_scenario = next((s for s in all_scenarios if s.name == dep), None)
                                if dep_scenario:
                                    scenario_builder.build_scenario(dep_scenario, debug_stop=debug_stop)
                                    graph.mark_scenario_built(dep)
                                    logger.info(f"‚úÖ Built dependency: {dep}")
                                else:
                                    logger.error(f"‚ùå Dependency '{dep}' not found in available scenarios")
                    
                    logger.info(f"\n--- Building {scenario.name} (Layer {layer_index}) ---")
                    scenario_builder.build_scenario(scenario, debug_stop=debug_stop)
                    logger.info(f"‚úÖ Successfully built: {scenario.name}")
                    successful_builds += 1
                    
                    # Mark as built in the graph
                    graph.mark_scenario_built(scenario_name)
                    
                except Exception as e:
                    logger.error(f"‚ùå Failed to build {scenario_name}: {e}")
                    # Continue with other scenarios in the layer
            
                    # After building this layer, reload guides with updated system knowledge
        if layer_index < len(build_layers):
            logger.info(f"\nüîÑ Reloading guides with updated system knowledge after Layer {layer_index}...")
            load_command(scenarios_path, skip_setup=True)
            
            # Rebuild the graph with updated guides
            graph_builder = container.get('scenario_graph_builder')
            graph = graph_builder.build_graph_from_guides()
        
        # Summary
        total_scenarios = len(scenarios_to_build)
        if successful_builds == total_scenarios:
            logger.info(f"\nüéâ Successfully built all {total_scenarios} scenarios in {len(build_layers)} layers!")
        else:
            logger.warning(f"\n‚ö†Ô∏è  Built {successful_builds}/{total_scenarios} scenarios")
            if successful_builds < total_scenarios:
                sys.exit(1)
    except Exception as e:
        logger.error(f"‚ùå Build failed: {e}")
        sys.exit(1)


def init_command():
    """Initialize the GlyphQA project structure."""
    try:
        # Create DI container
        container = create_container()
        config = container.get('config')
        target = container.get('target')
        logger.info(f"Initialized target: {target.name}")
        
        logger.info("Setting up test environment...")
        target.init()
        logger.info("‚úÖ Project initialized successfully!")
        
    except Exception as e:
        logger.error(f"‚ùå Initialization failed: {e}")
        sys.exit(1)


def purge_command():
    """Purge all cached knowledge and start fresh."""
    try:
        # Create DI container
        container = create_container()
        caching_system = container.get('hash_caching')
        system_state_storage_manager = container.get('system_state_storage_manager')
        
        logger.info("üßπ Purging cached knowledge...")
        
        # Purge cached knowledge
        caching_system.purge_cached_knowledge(system_state_storage_manager)
        
        # Remove glyph.md if it exists
        filesystem = container.get('filesystem')
        glyph_md_path = '.glyph/glyph.md'
        if filesystem.exists(glyph_md_path):
            filesystem.unlink(glyph_md_path)
            logger.info("üóëÔ∏è  Removed glyph.md")
        
        logger.info("‚úÖ Cache purged successfully!")
        
    except Exception as e:
        logger.error(f"‚ùå Purge failed: {e}")
        sys.exit(1)


def visualize_command(scenario_name: str = None, tree: bool = False):
    """Visualize the scenario dependency graph."""
    try:
        from core.scenario_graph import ScenarioGraphBuilder
        
        guides_dir = Path('.glyph/guides')
        if not guides_dir.exists():
            logger.error("No guides found. Run 'glyph load' first.")
            sys.exit(1)
        
        builder = ScenarioGraphBuilder(guides_dir)
        graph = builder.build_graph_from_guides()
        
        if tree and scenario_name:
            print(graph.visualize_dependency_tree(scenario_name))
        elif scenario_name:
            print(graph.visualize_graph(scenario_name))
        else:
            print(graph.visualize_graph())
            
    except Exception as e:
        logger.error(f"‚ùå Visualization failed: {e}")
        sys.exit(1)


def main():
    parser = argparse.ArgumentParser(description='GlyphQA - LLM-powered test automation framework')
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Init command
    init_parser = subparsers.add_parser('init', help='Initialize the project structure')
    
    # Load command
    load_parser = subparsers.add_parser('load', help='Load scenarios and convert to .guide files')
    load_parser.add_argument('--scenarios', help='Path to scenarios directory (default: scenarios/)')
    
    # Build command
    build_parser = subparsers.add_parser('build', help='Build Playwright tests from scenarios')
    build_parser.add_argument('--scenarios', help='Path to scenarios directory (default: scenarios/)')
    build_parser.add_argument('--scenario', help='Build specific scenario file')
    build_parser.add_argument('--debug-stop', type=int, help='Stop at specific action number for debugging')
    build_parser.add_argument('--purge', action='store_true', help='Remove all cached knowledge and start fresh')
    
    # Purge command
    purge_parser = subparsers.add_parser('purge', help='Purge all cached knowledge and start fresh')
    
    # Visualize command
    visualize_parser = subparsers.add_parser('visualize', help='Visualize scenario dependency graph')
    visualize_parser.add_argument('--scenario', help='Focus on specific scenario')
    visualize_parser.add_argument('--tree', action='store_true', help='Show dependency tree instead of graph')
    
    args = parser.parse_args()
    
    if args.command == 'init':
        init_command()
    elif args.command == 'load':
        load_command(args.scenarios)
    elif args.command == 'build':
        build_command(args.scenarios, args.scenario, args.debug_stop, args.purge)
    elif args.command == 'purge':
        purge_command()
    elif args.command == 'visualize':
        visualize_command(args.scenario, args.tree)
    else:
        parser.print_help()


if __name__ == '__main__':
    main()
