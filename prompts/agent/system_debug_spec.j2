import { test, expect } from '@playwright/test';

test.describe('System Analysis', () => {
  test('Capture page state for system analysis', async ({ page }) => {
    // Set a reasonable timeout for debug execution
    test.setTimeout(15000);
    
    try {
        // Navigate to the application
        await page.goto('{{ base_url }}');
        await page.waitForLoadState('networkidle');
        
        // Execute existing specs to get to required state (actions only)
        console.log('DEBUG: existing_specs count:', {{ existing_specs|length }});
        console.log('DEBUG: sdk_functions count:', {{ sdk_functions|length }});
{% if sdk_functions %}
        console.log('Using SDK functions to reach required state...');
        // Import SDK functions
        const { {% for func in sdk_functions %}{{ func }}{% if not loop.last %}, {% endif %}{% endfor %} } = await import('../sdk.js');
        
        try {
            // Use SDK functions to get to the required state
            // This is more reliable than executing raw JavaScript steps
            console.log('Executing SDK functions to reach required state...');
            {% if 'login' in sdk_functions %}
            await login(page, 'username', 'password');
            {% elif 'completeAdminLoginWorkflow' in sdk_functions %}
            await completeAdminLoginWorkflow(page);
            {% elif 'completeLoginWorkflow' in sdk_functions %}
            await completeLoginWorkflow(page);
            {% endif %}
            {% if 'navigateToUsers' in sdk_functions %}
            await navigateToUsers(page);
            {% endif %}
            console.log('Finished executing SDK functions');
        } catch (sdkError) {
            console.log('SDK execution failed, falling back to raw steps:', sdkError.message);
            // Fallback to raw steps if SDK fails
{% if existing_specs %}
{% for spec in existing_specs %}
            try {
                console.log('Executing spec: {{ spec.name }}');
                console.log('DEBUG: About to execute accumulated steps...');
                {{ spec.js_code }}
                console.log('DEBUG: Accumulated steps executed successfully');
                await page.waitForTimeout(5000); // Wait longer for navigation to complete
            } catch (specError) {
                console.log('Spec failed:', '{{ spec.name }}', specError.message);
                console.log('DEBUG: Spec error details:', specError);
            }
{% endfor %}
{% endif %}
        }
{% elif existing_specs %}
        console.log('Executing existing specs to reach required state...');
{% for spec in existing_specs %}
        try {
            console.log('Executing spec: {{ spec.name }}');
            {{ spec.js_code }}
            await page.waitForTimeout(1000); // Wait between specs
        } catch (specError) {
            console.log('Spec failed:', '{{ spec.name }}', specError.message);
        }
{% endfor %}
        console.log('Finished executing existing specs');
{% else %}
        console.log('No existing specs or SDK functions - starting fresh');
{% endif %}
        
        // Wait for page to stabilize after login
        await page.waitForTimeout(3000);
        
        // Wait for network to be idle to ensure all content is loaded
        await page.waitForLoadState('networkidle');
        
    } catch (error) {
        console.log('Spec execution failed:', error.message);
    }
    
    // Capture context-driven page state based on current step
    const pageState = await page.evaluate(() => {
      const context = {
        url: window.location.href,
        title: document.title,
        timestamp: new Date().toISOString()
      };
      
      // Context-driven element selection based on current step
      const stepDescription = '{{ current_step_description }}';
      let selector = '';
      
      // Determine selector based on step context
      if (stepDescription.toLowerCase().includes('login') || stepDescription.toLowerCase().includes('password') || stepDescription.toLowerCase().includes('username')) {
        // Login context - focus on form elements
        selector = 'input[name="username"], input[name="password"], button[type="submit"], h4, div.card-body, div.card-header, form, label, div.d-grid, div.mb-3, strong';
      } else if (stepDescription.toLowerCase().includes('navigate') || stepDescription.toLowerCase().includes('click') || stepDescription.toLowerCase().includes('menu')) {
        // Navigation context - focus on interactive elements
        selector = 'nav, a, button, h2, h3, h5, div.card-header, div.card-body, span.navbar-brand, div.navbar-nav, a.nav-link';
      } else if (stepDescription.toLowerCase().includes('fill') || stepDescription.toLowerCase().includes('form') || stepDescription.toLowerCase().includes('submit') || stepDescription.toLowerCase().includes('save')) {
        // Form context - focus on form elements
        selector = 'form, input, select, textarea, button, label, fieldset, legend, div.card-body, div.card-header';
      } else if (stepDescription.toLowerCase().includes('table') || stepDescription.toLowerCase().includes('row') || stepDescription.toLowerCase().includes('data') || stepDescription.toLowerCase().includes('user')) {
        // Table/Data context - focus on data elements
        selector = 'table, tr, td, th, ul, ol, li, button, a, div.card, div.card-body, div.card-header, h3, h5, p, small, strong';
      } else if (stepDescription.toLowerCase().includes('modal') || stepDescription.toLowerCase().includes('dialog') || stepDescription.toLowerCase().includes('popup')) {
        // Modal context - focus on dialog elements
        selector = 'dialog, [role="dialog"], button, div.card, div.card-body, div.card-header, input, select, textarea, h2, h3, h5';
      } else if (stepDescription.toLowerCase().includes('logout') || stepDescription.toLowerCase().includes('sign out') || stepDescription.toLowerCase().includes('exit')) {
        // Logout context - focus on logout elements
        selector = 'button, a, nav, div.navbar-nav, span.navbar-text, button.btn-outline-light, h2, h3, h5';
      } else {
        // General context - capture comprehensive set of interactive and structural elements
        selector = 'button, a, input, select, textarea, nav, div, section, article, header, footer, main, aside, h1, h2, h3, h4, h5, h6, p, span, ul, ol, li, form, fieldset, legend, label, table, tr, td, th, img, svg, [role="button"], [role="link"], [role="navigation"], [role="main"], [role="banner"], [role="contentinfo"], [role="complementary"], [role="region"], [role="list"], [role="listitem"], [role="menuitem"], [role="tab"], [role="tabpanel"], [role="dialog"], [role="alert"], [role="status"], [role="log"], [role="marquee"], [role="timer"], [role="progressbar"], [role="slider"], [role="spinbutton"], [role="textbox"], [role="searchbox"], [role="combobox"], [role="listbox"], [role="option"], [role="radio"], [role="checkbox"], [role="switch"], [role="tablist"], [role="tree"], [role="treeitem"], [role="grid"], [role="gridcell"], [role="columnheader"], [role="rowheader"], [role="row"], [role="cell"], [role="rowgroup"], [role="column"], [role="presentation"], [role="none"], [role="application"], [role="document"], [role="article"], [role="banner"], [role="complementary"], [role="contentinfo"], [role="form"], [role="main"], [role="navigation"], [role="region"], [role="search"], [role="tablist"], [role="toolbar"]';
      }
      
      const allElements = document.querySelectorAll(selector);
      context.elements = Array.from(allElements).map(el => {
        return {
          tag: el.tagName.toLowerCase(),
          textContent: el.textContent?.trim() || null,
          className: el.className || null,
          id: el.id || null,
          type: el.type || null,
          href: el.href || null,
          value: el.value || null
        };
      }).filter(el => {
        // Filter out empty or meaningless elements
        if (!el.textContent && !el.id && !el.className && !el.type && !el.href) return false;
        // Filter out script and style tags
        if (el.tag === 'script' || el.tag === 'style') return false;
        // Filter out elements with no visible content
        if (el.textContent && el.textContent.length < 2) return false;
        return true;
      });
      
      return context;
    });
    
    console.log('Page State:', JSON.stringify(pageState, null, 2));
  });
});
