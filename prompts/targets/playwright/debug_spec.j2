import { test, expect } from '@playwright/test';

test.describe('Debug Page State', () => {
  test('Capture page state after actions', async ({ page }) => {
    await page.goto('/');
    
    {{ implemented_actions }}
    
    // Capture comprehensive page state
    const pageState = await page.evaluate(() => {
      // Navigation history (last 5 items)
      const history = [];
      for (let i = 0; i < Math.min(5, window.history.length); i++) {
        history.push(window.location.href);
      }
      
      // All interactive elements with their attributes and values
      const allElements = Array.from(document.querySelectorAll('input, select, textarea, button, a, label'));
      const elements = allElements.map(el => ({
        tag: el.tagName.toLowerCase(),
        type: el.type || null,
        name: el.name || null,
        id: el.id || null,
        placeholder: el.placeholder || null,
        value: el.value || null,
        ariaLabel: el.getAttribute && el.getAttribute('aria-label') || null,
        textContent: el.textContent?.trim() || null,
        href: el.href || null,
        // Generic visibility detection that works with modals and any positioning
        visible: (() => {
          const computedStyle = window.getComputedStyle(el);
          return computedStyle.display !== 'none' && 
                 computedStyle.visibility !== 'hidden' &&
                 parseFloat(computedStyle.opacity) > 0;
        })(),
        enabled: !el.disabled,
        // Generate reliable selectors
        selectors: {
          byName: el.name ? `[name="${el.name}"]` : null,
          byId: el.id ? `#${el.id}` : null,
          byPlaceholder: el.placeholder ? `[placeholder="${el.placeholder}"]` : null,
          byAriaLabel: el.getAttribute && el.getAttribute('aria-label') ? `[aria-label="${el.getAttribute('aria-label')}"]` : null,
          byText: el.textContent?.trim() ? `text="${el.textContent.trim()}"` : null,
          byHref: el.href ? `a[href="${el.href}"]` : null
        }
      }));
      
      // Helper function to generate modal selectors - Generic approach for any modal implementation
      function _getModalSelector(modal) {
        // Priority 1: ID selector (most specific)
        if (modal.id) return `#${modal.id}`;
        
        // Priority 2: Framework-specific data attributes
        if (modal.getAttribute('data-modal')) return `[data-modal="${modal.getAttribute('data-modal')}"]`;
        if (modal.getAttribute('data-dialog')) return `[data-dialog="${modal.getAttribute('data-dialog')}"]`;
        if (modal.getAttribute('data-popup')) return `[data-popup="${modal.getAttribute('data-popup')}"]`;
        
        // Priority 3: Semantic attributes
        if (modal.getAttribute('role') === 'dialog') return '[role="dialog"]';
        if (modal.getAttribute('aria-modal') === 'true') return '[aria-modal="true"]';
        
        // Priority 4: Class-based selectors (framework-specific)
        const classes = Array.from(modal.classList);
        const modalClasses = classes.filter(cls => 
          cls.includes('modal') || 
          cls.includes('dialog') || 
          cls.includes('popup') ||
          cls.includes('overlay')
        );
        if (modalClasses.length > 0) return `.${modalClasses[0]}`;
        
        // Priority 5: Fallback to role="dialog"
        return '[role="dialog"]';
      }
      
      // Visible interactive elements
      const visibleElements = elements.filter(el => el.visible && el.enabled);
      
      // Form structure with submit buttons and modal context
      const forms = Array.from(document.querySelectorAll('form')).map(form => {
        // Find submit buttons that belong to this form
        const formSubmitButtons = Array.from(form.querySelectorAll('button[type="submit"]')).map(btn => ({
          text: btn.textContent?.trim() || null,
          type: btn.type,
          enabled: btn.disabled === false,
          // Generic visibility detection that works with modals
          visible: (() => {
            const computedStyle = window.getComputedStyle(btn);
            return computedStyle.display !== 'none' && 
                   computedStyle.visibility !== 'hidden' &&
                   parseFloat(computedStyle.opacity) > 0;
          })(),
          selectors: {
            byText: btn.textContent?.trim() ? `text="${btn.textContent.trim()}"` : null,
            byType: `button[type="submit"]`,
            byForm: `form:has(button[type="submit"]) button[type="submit"]`
          }
        }));
        
        // Check if this form is inside a modal
        const modalParent = form.closest('[role="dialog"], .modal, [aria-modal="true"]');
        const isInModal = modalParent !== null;
        
        return {
          id: form.id || null,
          action: form.action || null,
          method: form.method || null,
          isInModal: isInModal,
          modalSelector: isInModal ? _getModalSelector(modalParent) : null,
          elements: Array.from(form.elements).map(el => ({
            name: el.name || null,
            type: el.type || null,
            value: el.value || null,
            placeholder: el.placeholder || null
          })),
          submitButtons: formSubmitButtons
        };
      });
      
      // Modal detection and analysis - Generic approach for any modal implementation
      const modalSelectors = '[role="dialog"], [aria-modal="true"], .modal, .dialog, .popup, .overlay, [data-modal], [data-dialog], [data-popup], [data-overlay], [data-bs-toggle="modal"], [data-toggle="modal"]';
      const modals = Array.from(document.querySelectorAll(modalSelectors)).filter(modal => {
        // Filter out non-modal elements (like body.modal-open)
        const classes = Array.from(modal.classList);
        const isModalElement = (
          modal.getAttribute('role') === 'dialog' ||
          modal.getAttribute('aria-modal') === 'true' ||
          classes.some(cls => ['modal', 'dialog', 'popup', 'overlay'].includes(cls)) ||
          modal.getAttribute('data-modal') ||
          modal.getAttribute('data-dialog') ||
          modal.getAttribute('data-popup') ||
          modal.getAttribute('data-overlay')
        );
        
        // Exclude body and html elements
        return isModalElement && !['BODY', 'HTML'].includes(modal.tagName);
      }).map(modal => {
        // Generic modal visibility detection that works with any framework
        const computedStyle = window.getComputedStyle(modal);
        const classes = Array.from(modal.classList);
        
        // Check multiple visibility indicators for different modal frameworks
        const isVisible = (
          // CSS display/visibility/opacity checks
          computedStyle.display !== 'none' && 
          computedStyle.visibility !== 'hidden' &&
          parseFloat(computedStyle.opacity) > 0 &&
          
          // Framework-specific visibility classes
          (classes.some(cls => ['show', 'visible', 'active', 'open', 'expanded'].includes(cls)) ||
           !classes.some(cls => ['hide', 'hidden', 'd-none', 'collapsed', 'closed'].includes(cls))) &&
          
          // Position and size checks (modals should have meaningful dimensions)
          parseFloat(computedStyle.width) > 0 &&
          parseFloat(computedStyle.height) > 0 &&
          
          // Z-index check (modals typically have high z-index)
          parseInt(computedStyle.zIndex) > 0
        );
        
        const forms = Array.from(modal.querySelectorAll('form'));
        const submitButtons = Array.from(modal.querySelectorAll('button[type="submit"]'));
        const closeButtons = Array.from(modal.querySelectorAll('button[aria-label="Close"], .close, [data-dismiss="modal"], [data-close], [data-bs-dismiss="modal"]'));
        
        return {
          selector: _getModalSelector(modal),
          isVisible: isVisible,
          role: modal.getAttribute('role') || null,
          ariaModal: modal.getAttribute('aria-modal') || null,
          forms: forms.map(form => ({
            id: form.id || null,
            action: form.action || null,
            method: form.method || null,
            elements: Array.from(form.elements).map(el => ({
              name: el.name || null,
              type: el.type || null,
              value: el.value || null,
              placeholder: el.placeholder || null
            }))
          })),
          submitButtons: submitButtons.map(btn => ({
            text: btn.textContent?.trim() || null,
            type: btn.type,
            enabled: btn.disabled === false,
            // Generic visibility detection that works with modals
            visible: (() => {
              const computedStyle = window.getComputedStyle(btn);
              return computedStyle.display !== 'none' && 
                     computedStyle.visibility !== 'hidden' &&
                     parseFloat(computedStyle.opacity) > 0;
            })(),
            selectors: {
              byText: btn.textContent?.trim() ? `text="${btn.textContent.trim()}"` : null,
              byType: `button[type="submit"]`,
              byModal: `${_getModalSelector(modal)} button[type="submit"]`
            }
          })),
          closeButtons: closeButtons.map(btn => ({
            text: btn.textContent?.trim() || null,
            ariaLabel: btn.getAttribute('aria-label') || null,
            // Generic visibility detection that works with modals
            visible: (() => {
              const computedStyle = window.getComputedStyle(btn);
              return computedStyle.display !== 'none' && 
                     computedStyle.visibility !== 'hidden' &&
                     parseFloat(computedStyle.opacity) > 0;
            })(),
            selectors: {
              byText: btn.textContent?.trim() ? `text="${btn.textContent.trim()}"` : null,
              byAriaLabel: btn.getAttribute('aria-label') ? `[aria-label="${btn.getAttribute('aria-label')}"]` : null,
              byModal: `${_getModalSelector(modal)} button[aria-label="Close"]`
            }
          }))
        };
      });
      
      // Non-form buttons (like modal openers) with enhanced context - Generic approach
      const nonFormButtons = Array.from(document.querySelectorAll('button:not([type="submit"])')).map(btn => {
        const text = btn.textContent?.trim() || null;
        const attributes = Array.from(btn.attributes).map(attr => `${attr.name}="${attr.value}"`);
        
        // Generic modal opener detection for any framework
        const isModalOpener = (
          // Text-based detection (common patterns)
          text && (
            text.toLowerCase().includes('create') || 
            text.toLowerCase().includes('add') || 
            text.toLowerCase().includes('new') ||
            text.toLowerCase().includes('open') ||
            text.toLowerCase().includes('show') ||
            text.toLowerCase().includes('edit') ||
            text.toLowerCase().includes('settings') ||
            text.toLowerCase().includes('configure')
          ) ||
          
          // Framework-specific data attributes
          btn.getAttribute('data-toggle') === 'modal' ||
          btn.getAttribute('data-bs-toggle') === 'modal' ||
          btn.getAttribute('data-target') ||
          btn.getAttribute('data-bs-target') ||
          btn.getAttribute('data-modal') ||
          btn.getAttribute('data-dialog') ||
          btn.getAttribute('data-popup') ||
          
          // ARIA attributes
          btn.getAttribute('aria-haspopup') === 'true' ||
          btn.getAttribute('aria-expanded') === 'true' ||
          
          // Event handlers (indicates interactive behavior)
          btn.onclick !== null ||
          btn.getAttribute('onclick')
        );
        
        const opensModal = isModalOpener;
        
        return {
          text: text,
          type: btn.type || 'button',
          enabled: btn.disabled === false,
          // Generic visibility detection that works with modals
          visible: (() => {
            const computedStyle = window.getComputedStyle(btn);
            return computedStyle.display !== 'none' && 
                   computedStyle.visibility !== 'hidden' &&
                   parseFloat(computedStyle.opacity) > 0;
          })(),
          purpose: isModalOpener || opensModal ? 'modal_opener' : 'action',
          isModalOpener: isModalOpener || opensModal,
          selectors: {
            byText: text ? `text="${text}"` : null,
            byType: `button[type="${btn.type || 'button'}"]`,
            byPurpose: isModalOpener || opensModal ? 'button[data-purpose="modal_opener"]' : null
          }
        };
      });
      
      // Enhanced navigation detection - capture all navigation-related elements
      const navigationElements = elements.filter(el => {
        const text = el.textContent?.trim().toLowerCase() || '';
        const classes = Array.from(el.classList);
        
        // Navigation links (nav-link, nav-item, etc.)
        const isNavLink = (
          el.tag === 'a' && (
            classes.some(cls => ['nav-link', 'nav-item', 'navbar-nav'].includes(cls)) ||
            text.match(/^(dashboard|users|settings|profile|admin|home|main|navigation)$/)
          )
        );
        
        // Navigation buttons (tabs, menu toggles, etc.)
        const isNavButton = (
          el.tag === 'button' && (
            classes.some(cls => ['nav-tab', 'tab-button', 'menu-toggle'].includes(cls)) ||
            text.match(/^(dashboard|users|settings|profile|admin|home|main|navigation|menu|toggle)$/)
          )
        );
        
        // Action buttons that are part of navigation (create, add, export, etc.)
        const isActionButton = (
          el.tag === 'button' && (
            classes.some(cls => ['btn', 'btn-primary', 'btn-secondary', 'btn-outline'].includes(cls)) ||
            text.match(/^(create|add|new|edit|delete|export|import|generate|report|manage|configure)$/)
          )
        );
        
        // Breadcrumbs and pagination
        const isBreadcrumb = (
          el.tag === 'a' && (
            classes.some(cls => ['breadcrumb', 'breadcrumb-item', 'pagination', 'page-link'].includes(cls)) ||
            text.match(/^(previous|next|first|last|page|home|back|forward)$/)
          )
        );
        
        return isNavLink || isNavButton || isActionButton || isBreadcrumb;
      }).map(el => ({
        tag: el.tagName.toLowerCase(),
        text: el.textContent?.trim() || '',
        classes: Array.from(el.classList),
        type: el.type || null,
        href: el.href || null,
        visible: el.visible,
        enabled: el.enabled,
        // Generate reliable selectors for navigation
        selectors: {
          byText: el.textContent?.trim() ? `text="${el.textContent.trim()}"` : null,
          byClass: el.className ? `.${el.className.split(' ').filter(cls => cls.trim()).join('.')}` : null,
          byTag: el.tagName.toLowerCase(),
          byType: el.type ? `[type="${el.type}"]` : null,
          byHref: el.href ? `a[href="${el.href}"]` : null,
          // Bootstrap-specific selectors
          byBootstrap: (() => {
            if (el.classList.contains('nav-link')) return '.nav-link';
            if (el.classList.contains('btn')) return `.btn.${Array.from(el.classList).filter(cls => cls.startsWith('btn-')).join('.')}`;
            return null;
          })()
        }
      }));
      
      // Form elements specifically (exclude buttons, they're handled separately)
      const formElements = elements.filter(el => 
        ['input', 'select', 'textarea'].includes(el.tag)
      );
      
      // Comprehensive interaction report with modal and form relationships
      const interactionReport = {
        forms: forms.map(form => ({
          id: form.id,
          action: form.action,
          method: form.method,
          isInModal: form.isInModal,
          modalSelector: form.modalSelector,
          elements: form.elements,
          submitButtons: form.submitButtons
        })),
        modals: modals.map(modal => ({
          selector: modal.selector,
          isVisible: modal.isVisible,
          role: modal.role,
          ariaModal: modal.ariaModal,
          forms: modal.forms,
          submitButtons: modal.submitButtons,
          closeButtons: modal.closeButtons
        })),
        modalOpeners: nonFormButtons.filter(btn => btn.purpose === 'modal_opener'),
        actionButtons: nonFormButtons.filter(btn => btn.purpose === 'action'),
        navigation: navigationElements,
        inputs: elements.filter(el => el.tag === 'input').map(el => ({
          type: el.type,
          name: el.name,
          placeholder: el.placeholder,
          value: el.value,
          enabled: el.enabled,
          visible: el.visible,
          selectors: el.selectors
        })),
        selects: elements.filter(el => el.tag === 'select').map(el => ({
          name: el.name,
          options: el.options ? Array.from(el.options).map(opt => ({ value: opt.value, text: opt.text })) : [],
          enabled: el.enabled,
          visible: el.visible,
          selectors: el.selectors
        })),
        links: elements.filter(el => el.tag === 'a').map(el => ({
          text: el.textContent,
          href: el.href,
          enabled: el.enabled,
          visible: el.visible,
          selectors: el.selectors
        })),
        labels: elements.filter(el => el.tag === 'label').map(el => ({
          text: el.textContent,
          for: el.getAttribute ? el.getAttribute('for') : null,
          visible: el.visible,
          selectors: el.selectors
        }))
      };
      
      return {
        url: window.location.href,
        title: document.title,
        history: history,
        elements: elements,
        visibleElements: visibleElements,
        navigationElements: navigationElements,
        formElements: formElements,
        forms: forms,
        modals: modals,
        nonFormButtons: nonFormButtons,
        interactionReport: interactionReport,
        elementCounts: {
          total: elements.length,
          visible: visibleElements.length,
          forms: forms.length,
          inputs: elements.filter(el => el.tag === 'input').length,
          submitButtons: forms.reduce((count, form) => count + (form.submitButtons ? form.submitButtons.length : 0), 0),
          modalOpeners: nonFormButtons.filter(btn => btn.purpose === 'modal_opener').length,
          actionButtons: nonFormButtons.filter(btn => btn.purpose === 'action').length,
          selects: elements.filter(el => el.tag === 'select').length,
          links: elements.filter(el => el.tag === 'a').length,
          labels: elements.filter(el => el.tag === 'label').length
        }
      };
    });
    
    console.log('Current URL:', await page.url());
    console.log('Page Title:', await page.title());
    console.log('Page State:', JSON.stringify(pageState, null, 2));
  });
});
